[
    {
        "case number": "0",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "1",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "2",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "3",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "4",
        "code": "import math\n\n\ndef py_stddev(a):\n    mean = sum(a) / len(a)\n    return math.sqrt((sum(((x - mean) ** 2 for x in a)) / len(a)))\n\n",
        "unittest": "from array import array\nimport timeit\n\nfrom fm import sd, sd2\n\n\ndef test_py_sd():\n    a = array(\"h\", range(10000))\n    func = sd.py_stddev\n    assert int(func(a)) == 2886\n    print(func, timeit.timeit(lambda: func(a), number=1000))\n\n\ndef test_py_sd2():\n    a = array(\"h\", range(10000))\n    func = sd2.py_stddev\n    assert int(func(a)) == 2886\n    print(func, timeit.timeit(lambda: func(a), number=1000))\n\n\ndef test_py_sd_cy():\n    a = array(\"h\", range(10000))\n    func = sd2.cy_stddev\n    assert int(func(a)) == 2886\n    print(func, timeit.timeit(lambda: func(a), number=1000))\n\n"
    },
    {
        "case number": "5",
        "code": "from toolz import curry\n\n\n@curry\ndef intersperse(separator, xs):\n    \"\"\"Creates a new list with the separator interposed between elements.\n    Dispatches to the intersperse method of the second argument, if present\"\"\"\n    if hasattr(xs, \"intersperse\"):\n        return xs.intersperse(separator)\n    out = [xs[0]]\n    for x in xs[1:]:\n        out += [separator, x]\n\n    return out\n\n",
        "unittest": "from ramda.intersperse import intersperse\nfrom ramda.private.asserts import *\n\n\ndef test_intesperse():\n    xs = [\"ba\", \"a\", \"a\"]\n    assert_equal(intersperse(\"n\", xs), [\"ba\", \"n\", \"a\", \"n\", \"a\"])\n\n    class XS:\n        def intersperse(self, separator):\n            return [separator for x in xs]\n\n    assert_equal(intersperse(\"n\", XS()), [\"n\", \"n\", \"n\"])\n\n"
    },
    {
        "case number": "6",
        "code": "# 1111. Maximum Nesting Depth of Two Valid Parentheses Strings\nclass Solution:\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\n        c = 0\n        ans = [0] * len(seq)\n        for i, br in enumerate(seq):\n            if br == '(':\n                c += 1\n                ans[i] = c % 2\n            else:\n                ans[i] = c % 2\n                c -= 1\n\n        return ans\n",
        "unittest": "# 1111. Maximum Nesting Depth of Two Valid Parentheses Strings\nclass Solution:\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\n        c = 0\n        ans = [0] * len(seq)\n        for i, br in enumerate(seq):\n            if br == '(':\n                c += 1\n                ans[i] = c % 2\n            else:\n                ans[i] = c % 2\n                c -= 1\n\n        return ans\n"
    },
    {
        "case number": "7",
        "code": "def substrings_in_strings(substrings, strings):\n    if type(strings) != list:\n        strings = [strings]\n    if type(substrings) != list:\n        substrings = [substrings]\n    for string in strings:\n        for substring in substrings:\n            if substring == \"\":\n                continue\n            if substring in string:\n                return string\n    return \"\"\n\n",
        "unittest": "from signatures.checks import helpers\n\n\n## substrings_in_strings\ndef test_substrings_in_strings_for_single_string():\n    assert helpers.substrings_in_strings(\"abc\", \"abc\") == \"abc\"\n\n\ndef test_substrings_in_strings_for_single_substring():\n    assert helpers.substrings_in_strings(\"b\", \"abc\") == \"abc\"\n\n\ndef test_substrings_in_strings_for_multiple_substring():\n    assert helpers.substrings_in_strings([\"a\", \"b\", \"c\"], \"abc\") == \"abc\"\n\n\ndef test_substrings_in_strings_returns_first_for_multiple_strings():\n    assert helpers.substrings_in_strings(\"a\", [\"abc\", \"aed\"]) == \"abc\"\n\n\ndef test_substrings_in_strings_no_subtrings():\n    assert helpers.substrings_in_strings(\"\", [\"abc\", \"aed\"]) == \"\"\n\n\ndef test_substrings_in_strings_no_strings():\n    assert helpers.substrings_in_strings(\"a\", \"\") == \"\"\n\n\ndef test_substrings_in_strings_nothing():\n    assert helpers.substrings_in_strings(\"\", \"\") == \"\"\n\n"
    },
    {
        "case number": "8",
        "code": "def product(xs):\n    \"\"\"Multiplies together all the elements of a list\"\"\"\n    result = xs[0]\n    for x in xs[1:]:\n        result *= x\n    return result\n\n",
        "unittest": "from ramda import product\nfrom ramda.private.asserts import assert_equal\n\n\ndef test_product():\n    assert_equal(product([2, 3, 5]), 30)\n\n"
    },
    {
        "case number": "9",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "10",
        "code": "# Code Listing - #12\n\n\"\"\"\nModule palindrome - Returns whether an input string is palindrome or not\n\"\"\"\n\n# Note - this is the first version of palindrome, so called palindrome1.py\n\ndef is_palindrome(in_string):\n    \"\"\" Returns True whether in_string is palindrome, False otherwise \"\"\"\n\n    # Case insensitive\n    in_string = in_string.lower()\n    # Check if string is same as in reverse\n    return in_string == in_string[-1::-1]\n\n",
        "unittest": "# Code Listing - #11\n\n\"\"\"\nModule test_palindrome - TDD for palindrome module\n\"\"\"\n\n# Note: This is the first version of test_palindrome, so called test_palindrome1.py\n\nimport palindrome\n\ndef test_basic():\n    \"\"\" Basic test for palindrome \"\"\"\n\n    # True positives\n    for test in ('Rotator','bob','madam','mAlAyAlam', '1'):\n        assert palindrome.is_palindrome(test)==True\n\n    # True negatives\n    for test in ('xyz','elephant', 'Country'):\n        assert palindrome.is_palindrome(test)==False        \n\n\n"
    },
    {
        "case number": "11",
        "code": "\ufeff#  Copyright \u00a9 2002-2010 Zooko Wilcox-O'Hearn\n#  This file is part of pyutil; see README.rst for licensing terms.\n\n\"\"\"\nWhat word has three letters and a 'x' in it?\n\nNot that one silly.\n\"\"\"\n\nimport warnings\nimport array, operator\n\nfrom pyutil.assertutil import precondition\n\ndef py_xor(str1, str2):\n    warnings.warn(\"deprecated\", DeprecationWarning)\n    precondition(len(str1) == len(str2), \"str1 and str2 are required to be of the same length.\", str1=str1, str2=str2)\n\n    if len(str1)%4 == 0:\n        a1 = array.array('i', str1)\n        a2 = array.array('i', str2)\n        for i in range(len(a1)):\n            a2[i] = a2[i]^a1[i]\n    elif len(str1)%2 == 0:\n        a1 = array.array('h', str1)\n        a2 = array.array('h', str2)\n        for i in range(len(a1)):\n            a2[i] = a2[i]^a1[i]\n    else:\n        a1 = array.array('c', str1)\n        a2 = array.array('c', str2)\n        for i in range(len(a1)):\n            a2[i] = chr(ord(a2[i])^ord(a1[i]))\n\n    return a2.tostring()\n\ndef py_xor_simple(str1, str2):\n    \"\"\"\n    Benchmarks show that this is the same speed as py_xor() for small strings\n    and much slower for large strings, so don't use it. --Zooko 2002-04-29\n    \"\"\"\n    warnings.warn(\"deprecated\", DeprecationWarning)\n    precondition(len(str1) == len(str2), \"str1 and str2 are required to be of the same length.\", str1=str1, str2=str2)\n\n    return ''.join(map(chr, map(operator.__xor__, map(ord, str1), map(ord, str2))))\n\n# Now make \"xor.xor()\" be the best xor we've got:\nxor = py_xor\n\n# for unit tests, see pyutil/test/test_xor.py.  For benchmarks, see pyutil/test/bench_xor.py.\n\n",
        "unittest": "#!/usr/bin/env python\n\n#  Copyright (c) 2002-2009 Zooko Wilcox-O'Hearn\n#  portions Copyright (c) 2001 Autonomous Zone Industries\n#  This file is part of pyutil; see README.rst for licensing terms.\n#\nimport unittest\n\nfrom pyutil.xor import xor\n\n# unit tests\ndef _help_test(xf):\n    assert xf('\\000', '\\000') == '\\000'\n    assert xf('\\001', '\\000') == '\\001'\n    assert xf('\\001', '\\001') == '\\000'\n    assert xf('\\000\\001', '\\000\\001') == '\\000\\000'\n    assert xf('\\100\\101', '\\000\\101') == '\\100\\000'\n\nclass Testy(unittest.TestCase):\n    def test_em(self):\n        for xorfunc in (xor.py_xor, xor.py_xor_simple, xor.xor,):\n            if callable(xorfunc):\n                # print \"testing xorfunc \", xorfunc\n                _help_test(xorfunc)\n\n"
    },
    {
        "case number": "12",
        "code": "\ndef get_max_length(list_of_strings):\n\tmax_len =-1\n\tfor i in list_of_strings:\n\t\tif (len(i) > max_len):\n\t\t\tmax_len = len(i)\n\t\t\tres = len(i)\n\treturn res\n\t\n",
        "unittest": "\nimport os\n\ndef generateTester(filename, rawSh,shellEntry):\n\n\tprevDir = '\\\\'.join((os.path.join(os.path.dirname(__file__))).split(\"\\\\\")[:-1])\n\t# print(prevDir)\n\ttemplatePath = os.path.join(os.path.dirname(__file__),\"tester_template.txt\")\n\n\ttesterPath = os.path.join(os.path.dirname(__file__), \"..\", \"logs\", filename, filename+\"_tester.c\")\n\tfp = open(templatePath, \"r\")\n\tfpData = fp.read()\n\n\t# print(fpData)\n\trawSh = rawSh.replace(\"String Literal:\", \"\").strip()\n\tnewData = fpData.replace(\"<code>\", rawSh)\n\n\tnewData = newData.replace(\"<size>\", str(len(rawSh)+1))\n\tnewData2 = newData.replace(\"<offset>\", str(shellEntry))\n\n\t# print(newData)\n\t\n\tfp.close()\n\n\tfp = open(testerPath, \"w\")\n\tfp.write(newData2)\n\tfp.close()\n\t# print(os.path.join(os.path.dirname(__file__), \"..\\\\\"))\n\n\n"
    },
    {
        "case number": "13",
        "code": "def gcd(a, b):\n    if a == 0:\n        return b\n\n    return gcd(b % a, a)\n\n",
        "unittest": "from unittest import TestCase\nfrom gcd import gcd\n\n\nclass GcdTest(TestCase):\n    def test_gcd(self):\n        assert gcd(16, 4) == 4\n        assert gcd(17, 5) == 1\n        assert gcd(30, 20) == 10\n        assert gcd(10, 0) == 10\n\n"
    },
    {
        "case number": "14",
        "code": "def remove_prefix(s: str, prefix: str) -> str:\n    if s.startswith(prefix):\n        return s[len(prefix):]\n    else:\n        return s\n\n\ndef remove_suffix(s: str, suffix: str) -> str:\n    if s.endswith(suffix):\n        return s[:-len(suffix)]\n    else:\n        return s\n\n",
        "unittest": "import unittest\n\nfrom nayvy.utils.string_utils import remove_prefix, remove_suffix\n\n\nclass Test(unittest.TestCase):\n\n    def test_remove_prefix(self) -> None:\n        assert remove_prefix('test_hoge', 'test_') == 'hoge'\n        return\n\n    def test_remove_suffix(self) -> None:\n        assert remove_suffix('hoge.py', '.py') == 'hoge'\n        return\n\n"
    },
    {
        "case number": "15",
        "code": "n = int(input())\ns = str(n)\nprint(s[-1])\n\n",
        "unittest": "n = int(input())\nx = hex(n)[-1]\nif x.isalpha():\n    x = ord(x) - 87\nprint(bin(int(x))[-1])\n\n"
    },
    {
        "case number": "16",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "17",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "18",
        "code": "# coding: utf-8\n\"\"\"\nhttps://leetcode.com/problems/implement-strstr/\n\"\"\"\n\n\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n\n        n_length = len(needle)\n        for i in range(len(haystack)):\n            if haystack[i:i + n_length] == needle:\n                return i\n\n        return -1\n\n\nclass Solution2:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n\n        n_length = len(needle)\n        h_length = len(haystack)\n\n        if h_length < n_length:\n            return -1\n\n        for i in range(h_length - n_length + 1):\n            if haystack[i:i + n_length] == needle:\n                return i\n\n        return -1\n\n",
        "unittest": "# coding: utf-8\nimport unittest\n\nfrom problems.implement_strstr import Solution\nfrom problems.implement_strstr import Solution2\n\n\nclass TestCase(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test(self):\n        haystack = 'hello'\n        needle = 'll'\n        expected = 2\n        self.assertEqual(self.solution.strStr(haystack, needle), expected)\n\n    def test2(self):\n        haystack = 'aaaaa'\n        needle = 'bba'\n        expected = -1\n        self.assertEqual(self.solution.strStr(haystack, needle), expected)\n\n    def test3(self):\n        haystack = 'xyz'\n        needle = ''\n        expected = 0\n        self.assertEqual(self.solution.strStr(haystack, needle), expected)\n\n    def test4(self):\n        haystack = 'hello'\n        needle = 'lo'\n        expected = 3\n        self.assertEqual(self.solution.strStr(haystack, needle), expected)\n\n    def test5(self):\n        haystack = 'aaa'\n        needle = 'aaaaaaa'\n        expected = -1\n        self.assertEqual(self.solution.strStr(haystack, needle), expected)\n\n\nclass TestCase2(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution2()\n\n    def test(self):\n        haystack = 'hello'\n        needle = 'll'\n        expected = 2\n        self.assertEqual(self.solution.strStr(haystack, needle), expected)\n\n    def test2(self):\n        haystack = 'aaaaa'\n        needle = 'bba'\n        expected = -1\n        self.assertEqual(self.solution.strStr(haystack, needle), expected)\n\n    def test3(self):\n        haystack = 'xyz'\n        needle = ''\n        expected = 0\n        self.assertEqual(self.solution.strStr(haystack, needle), expected)\n\n    def test4(self):\n        haystack = 'hello'\n        needle = 'lo'\n        expected = 3\n        self.assertEqual(self.solution.strStr(haystack, needle), expected)\n\n    def test5(self):\n        haystack = 'aaa'\n        needle = 'aaaaaaa'\n        expected = -1\n        self.assertEqual(self.solution.strStr(haystack, needle), expected)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\n"
    },
    {
        "case number": "19",
        "code": "import os\n\n\ndef create_folder(path: str) -> str:\n    \"\"\"Create folder, if it doesn't already exist\"\"\"\n    if not os.path.exists(path):\n        os.makedirs(path)\n    return path\n\n\ndef join_text_with_comma_and_and(values: list) -> str:\n    \"\"\"Merge values for text output with commas and only the last value\n    with an \"and\"\"\n\n    Args:\n        values (list): list of values to be merged.\n\n    Returns:\n        str: new text.\n    \"\"\"\n    if len(values) > 2:\n        last_value = values[-1]\n        values = \", \".join(values[:-1])\n        text = values + \", and \" + last_value\n\n    else:\n        text = \", and \".join(values)\n    return text\n\n\ndef get_number_to_string_dict() -> None:\n    \"\"\"Map number of features to string values\"\"\"\n    number_text = (\n        \"one\",\n        \"two\",\n        \"three\",\n        \"four\",\n        \"five\",\n        \"six\",\n        \"seven\",\n        \"eight\",\n        \"nine\",\n        \"ten\",\n        \"eleven\",\n        \"twelve\",\n        \"thirteen\",\n        \"fourteen\",\n        \"fifteen\",\n        \"sixteen\",\n        \"seventeen\",\n        \"eighteen\",\n        \"nineteen\",\n        \"twenty\",\n    )\n    num_to_str = {}\n    for text, number in zip(number_text, range(1, 21)):\n        num_to_str[number] = text\n    return num_to_str\n\n\nnum_to_str = get_number_to_string_dict()\n\n",
        "unittest": "import pandas as pd\nfrom sklearn.datasets import load_diabetes, load_iris\nfrom sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\nfrom sklearn.model_selection import train_test_split\n\n\ndef get_regression_model():\n    diabetes = load_diabetes()\n\n    X_train, X_test, y_train, y_test = train_test_split(\n        diabetes.data, diabetes.target, random_state=0\n    )\n    X_test = pd.DataFrame(X_test, columns=diabetes.feature_names)\n    y_test = pd.DataFrame(y_test)\n\n    model = RandomForestRegressor(random_state=0).fit(X_train, y_train)\n    return model, X_test, y_test\n\n\ndef get_classification_model():\n    iris = load_iris()\n\n    X_train, X_test, y_train, y_test = train_test_split(\n        iris.data, iris.target, random_state=0\n    )\n    X_test = pd.DataFrame(X_test, columns=iris.feature_names)\n    y_test = pd.DataFrame(y_test)\n\n    model = RandomForestClassifier(random_state=0).fit(X_train, y_train)\n    return model, X_test, y_test\n\n"
    },
    {
        "case number": "20",
        "code": "import math\n\n\ndef distance(pa, pb):\n    ax, ay = pa\n    bx, by = pb\n    return math.sqrt((ax - bx) ** 2 + (ay - by) ** 2)\n\n\ndef index_of_nearest(p, hot_points, distance_f=distance):\n    \"\"\"Given a point and a set of hot points it found the hot point\n    nearest to the given point. An arbitrary distance function can\n    be specified\n    :return the index of the nearest hot points, or None if the list of hot\n            points is empty\n    \"\"\"\n    min_dist = None\n    nearest_hp_i = None\n    for i, hp in enumerate(hot_points):\n        dist = distance_f(p, hp)\n        if min_dist is None or dist < min_dist:\n            min_dist = dist\n            nearest_hp_i = i\n    return nearest_hp_i\n\n",
        "unittest": "import unittest\nfrom worldengine.basic_map_operations import distance, index_of_nearest\n\n\nclass TestBasicMapOperations(unittest.TestCase):\n\n    def setUp(self):\n        pass\n\n    def test_distance(self):\n        self.assertAlmostEqual(22.360679774997898, distance((0, 0), (10, 20)))\n        self.assertAlmostEqual(22.360679774997898, distance((-1, -1), (9, 19)))\n        self.assertAlmostEqual(22.360679774997898, distance((-1, 9), (9, 29)))\n        self.assertAlmostEqual(22.360679774997898, distance((9, -1), (19, 19)))\n\n    def test_index_of_nearest(self):\n        self.assertTrue(index_of_nearest((0, 0), []) is None)\n        self.assertEqual(0, index_of_nearest(\n            (0, 0), [(0, 0), (10, 10), (7, 7), (-5, -5), (-2, 7)]))\n        self.assertEqual(3, index_of_nearest(\n            (-4, -4), [(0, 0), (10, 10), (7, 7), (-5, -5), (-2, 7)]))\n        self.assertEqual(3, index_of_nearest(\n            (-100, -100), [(0, 0), (10, 10), (7, 7), (-5, -5), (-2, 7)]))\n        self.assertEqual(3, index_of_nearest(\n            (-100.0, -100.0), [(0, 0), (10, 10), (7, 7), (-5, -5), (-2, 7)]))\n\nif __name__ == '__main__':\n    unittest.main()\n\n"
    },
    {
        "case number": "21",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "22",
        "code": "def filter_ints(v):\n    return [num for num in v if is_positive(num)]\n\ndef is_positive(n):\n    return n > 0\n\n\nif __name__ == \"__main__\":\n    print(filter_ints([3, -4, 0, 5, 8]))  # [3, 5, 8]\n\n",
        "unittest": "from unittest import TestCase  # 1\nfrom unittest.mock import patch, call  # 2\nfrom nose.tools import assert_equal, assert_list_equal  # 3\n\nfrom ch7.filter_funcs import filter_ints  # 4\n\n\nclass FilterIntsTestCase(TestCase):  # 5\n\n    @patch('ch7.filter_funcs.is_positive')  # 6\n    def test_filter_ints(self, is_positive_mock):  # 7\n        # preparation\n        v = [3, -4, 0, 5, 8]\n\n        # execution\n        filter_ints(v)  # 8\n\n        # verification\n        assert_equal(\n            [call(3), call(-4), call(0), call(5), call(8)],\n            is_positive_mock.call_args_list\n        )  # 9\n\n    def test_filter_ints_return_value(self):\n        v = [3, -4, 0, -2, 5, 0, 8, -1]\n\n        result = filter_ints(v)\n\n        assert_list_equal([3, 5, 8], result)\n\n"
    },
    {
        "case number": "23",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "24",
        "code": "#!/usr/bin/env python\n# encoding: utf-8\n\n\ndef gcd(m: int, n: int):\n    \"\"\"\n    compute the greatest common divisor of m and n;\n    :param m:\n    :param n:\n    :return:\n    \"\"\"\n    while n > 0:\n        rem = m % n\n        m = n\n        n = rem\n    return m\n\n",
        "unittest": "#!/usr/bin/env python\n# encoding: utf-8\nfrom unittest import TestCase\n\nfrom gcd import gcd\n\n\nclass TestGcd(TestCase):\n    def test_gcd(self):\n        self.assertEqual(gcd(10, 3), 1)\n        self.assertEqual(gcd(10, 4), 2)\n        self.assertEqual(gcd(10, 1), 1)\n        self.assertEqual(gcd(10, 5), 5)\n\n"
    },
    {
        "case number": "25",
        "code": "# coding: utf-8\n\"\"\"\nhttps://en.wikipedia.org/wiki/Factorial\n\n0! = 1\n1! = 1\nn! = n * (n - 1) * (n - 2) * (n - 3) * ... * 3 * 2 * 1\n\"\"\"\n\n\ndef factorial(n):\n    if not isinstance(n, int) or n < 0:\n        raise ValueError('n is invalid')\n\n    # Base case\n    if n <= 1:\n        return 1\n\n    # Recursive case\n    return n * factorial(n - 1)\n\n\ndef factorial_for_loop(n):\n    ans = 1\n    for i in range(1, n + 1):\n        ans = ans * i\n    return ans\n\n",
        "unittest": "# coding: utf-8\nimport math\nimport random\nimport unittest\n\nfrom algorithms.math.factorial import factorial\nfrom algorithms.math.factorial import factorial_for_loop\n\n\nclass TestCase(unittest.TestCase):\n    def test(self):\n        with self.assertRaises(ValueError):\n            factorial(-1)\n\n        with self.assertRaises(ValueError):\n            factorial(0.5)\n\n        with self.assertRaises(ValueError):\n            factorial('abc')\n\n        self.assertEqual(factorial(0), 1)\n        self.assertEqual(factorial(1), 1)\n        self.assertEqual(factorial(2), 2)\n        self.assertEqual(factorial(3), 6)\n        self.assertEqual(factorial(4), 24)\n        self.assertEqual(factorial(5), 120)\n        self.assertEqual(factorial(6), 720)\n        self.assertEqual(factorial(7), 5040)\n        self.assertEqual(factorial(8), 40320)\n        self.assertEqual(factorial(9), 362880)\n        self.assertEqual(factorial(10), 3628800)\n\n    def test_2(self):\n        rand_i = random.randint(0, 100)\n        self.assertEqual(factorial(rand_i), math.factorial(rand_i))\n\n\nclass TestCase2(unittest.TestCase):\n    def test(self):\n        self.assertEqual(factorial_for_loop(0), 1)\n        self.assertEqual(factorial_for_loop(1), 1)\n        self.assertEqual(factorial_for_loop(2), 2)\n        self.assertEqual(factorial_for_loop(3), 6)\n        self.assertEqual(factorial_for_loop(4), 24)\n        self.assertEqual(factorial_for_loop(5), 120)\n        self.assertEqual(factorial_for_loop(6), 720)\n        self.assertEqual(factorial_for_loop(7), 5040)\n        self.assertEqual(factorial_for_loop(8), 40320)\n        self.assertEqual(factorial_for_loop(9), 362880)\n        self.assertEqual(factorial_for_loop(10), 3628800)\n\n    def test_2(self):\n        rand_i = random.randint(0, 10000)\n        self.assertEqual(factorial_for_loop(rand_i), math.factorial(rand_i))\n\n\nif __name__ == '__main__':\n    unittest.main()\n\n"
    },
    {
        "case number": "26",
        "code": "from collections import Counter\nfrom collections.abc import Iterator\n\n\ndef find_duplicates(items: Iterator[str]) -> list[str]:\n    return [i for i, count in Counter(items).items() if count > 1]\n\n",
        "unittest": "from qgreenland.constants.paths import COMPILE_PACKAGE_DIR\nfrom qgreenland.util import layer as layer_util\n\n\ndef test_layer_compile_dir(raster_layer_node):\n    expected = COMPILE_PACKAGE_DIR / \"Group\" / \"Subgroup\" / \"Example raster\"\n    actual = layer_util.get_layer_compile_dir(raster_layer_node)\n\n    assert expected == actual\n\n\ndef test_vector_or_raster(online_layer_node):\n    assert layer_util.vector_or_raster(online_layer_node) == \"Raster\"\n\n"
    },
    {
        "case number": "27",
        "code": "def swap_case(string):\n    \"\"\"\n    Convert all lowercase letters to upercase letters and vice versa.\n    \"\"\"\n    return string.swapcase()\n\n\nif __name__ == '__main__':\n    s = input()\n    result = swap_case(s)\n    print(result)\n\n",
        "unittest": "#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\n\n\n# The function is expected to return a STRING.\n# The function accepts STRING sentence as parameter.\ndef reverse_words_order_and_swap_cases(sentence):\n    return reverse_words(sentence.swapcase())\n\ndef reverse_words(sentence):\n    return \" \".join(reversed(sentence.split(\" \")))\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    sentence = input()\n\n    result = reverse_words_order_and_swap_cases(sentence)\n\n    fptr.write(result + '\\n')\n\n    fptr.close()\n\n"
    },
    {
        "case number": "28",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "29",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "30",
        "code": "def add_num(num1, num2):\n    return num1 + num2\n\n\ndef is_positive(num):\n    return num > 0\n\n",
        "unittest": "# test_sample.py \u30c6\u30b9\u30c8\u3092\u3059\u308b\u5074\u306e\u30b3\u30fc\u30c9\nimport unittest\nimport sample\n\n\nclass TestNumberFuncs(unittest.TestCase):\n\n    def test_add_num(self):\n        \"\"\"\n        add_num\u306e\u5358\u4f53\u30c6\u30b9\u30c8\n        \"\"\"\n        self.assertEqual(7, sample.add_num(3, 4))\n\n    def test_is_positive(self):\n        \"\"\"\n        is_num\u306e\u5358\u4f53\u30c6\u30b9\u30c8\n        \"\"\"\n        self.assertTrue(sample.is_positive(3))\n        self.assertFalse(sample.is_positive(0))\n        self.assertFalse(sample.is_positive(-1))\n\n"
    },
    {
        "case number": "31",
        "code": "def is_prime(number):\n    if number < 0 or number in (0, 1):\n        return False\n\n    for element in range(2, number):\n        if number % element == 0:\n            return False\n\n    return True\n\n",
        "unittest": "import pytest\n\nfrom primes import is_prime\n\n\n@pytest.fixture()\ndef prime_numbers():\n    return [3, 5, 7]\n\n\n@pytest.fixture()\ndef non_prime_numbers():\n    return [8, 0, 1]\n\n\n@pytest.fixture()\ndef negative_numbers():\n    return [-1, -3, -6]\n\n\ndef test_is_prime_true(prime_numbers):\n    for number in prime_numbers:\n        assert is_prime(number)\n\n\ndef test_is_prime_false(non_prime_numbers, negative_numbers):\n    for number in non_prime_numbers:\n        assert not is_prime(number)\n\n    for number in negative_numbers:\n        assert not is_prime(number)\n\n"
    },
    {
        "case number": "32",
        "code": "'''\nGiven a non-negative integer x, compute and return the square root of x.\n\nSince the return type is an integer, the decimal digits are truncated,\n\nand only the integer part of the result is returned\n\nExample 1:\n\nInput: 4\nOutput: 2\nExample 2:\n\nInput: 8\nOutput: 2\nExplanation: The square root of 8 is 2.82842..., and since\n             the decimal part is truncated, 2 is returned.\n'''\n\nimport math\n\nclass SolutionLibrary:\n    def mySqrt(self, x):\n        return int(math.sqrt(x))\n\nclass Solution:\n    # Binary Search\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x == 0:\n            return 0\n\n        left = 1\n        right = x // 2 + 1\n\n        while left <= right:\n            mid = (right + left) // 2\n            if mid ** 2 <= x < (mid+1) ** 2:\n                return mid\n\n            if mid ** 2 > x:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n",
        "unittest": "import unittest\nfrom Sqrtx_069 import Solution\n\n'''\nGiven a non-negative integer x, compute and return the square root of x.\n\nSince the return type is an integer, the decimal digits are truncated,\n\nand only the integer part of the result is returned\n\nExample 1:\n\nInput: 4\nOutput: 2\nExample 2:\n\nInput: 8\nOutput: 2\nExplanation: The square root of 8 is 2.82842..., and since\n             the decimal part is truncated, 2 is returned.\n'''\n\n\nclass Test_Case(unittest.TestCase):\n\n    def test_answer_01(self):\n        x = 4\n        result = 2\n        self.assertEqual(Solution().mySqrt(x), result)\n\n    def test_answer_02(self):\n        x = 8\n        result = 2\n        self.assertEqual(Solution().mySqrt(x), result)\n\n    def test_answer_03(self):\n        x = 0\n        result = 0\n        self.assertEqual(Solution().mySqrt(x), result)\n\n    def test_answer_04(self):\n        x = 100\n        result = 10\n        self.assertEqual(Solution().mySqrt(x), result)\n\n    def test_answer_05(self):\n        x = 1\n        result = 1\n        self.assertEqual(Solution().mySqrt(x), result)\n\nif __name__ == '__main__':\n    unittest.main()\n\n"
    },
    {
        "case number": "33",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "34",
        "code": "def remove_duplicates(listofElements):\n    # Create an empty list to store unique elements\n    uniqueList = []\n\n    # Iterate over the original list and for each element\n    # add it to uniqueList, if its not already there.\n    for elem in listofElements:\n        if elem not in uniqueList:\n            uniqueList.append(elem)\n\n    # Return the list of unique elements\n    return uniqueList\n",
        "unittest": "from django.contrib.auth.models import Permission\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.shortcuts import resolve_url as r\nfrom model_mommy import mommy\n\nfrom sgce.core.tests.base import LoggedInTestCase\nfrom django.contrib.auth import get_user_model\n\n\nclass UserListWithoutPermission(LoggedInTestCase):\n    def setUp(self):\n        super(UserListWithoutPermission, self).setUp()\n        self.response = self.client.get(r('accounts:user-list'))\n\n    def test_get(self):\n        \"\"\"Must return 403 HttpError (No permission)\"\"\"\n        self.assertEqual(403, self.response.status_code)\n\n\n# Permission: auth.view_user\nclass UserListWithPermission(LoggedInTestCase):\n    def setUp(self):\n        super(UserListWithPermission, self).setUp()\n        # permission required: profile.can_enable_or_disable_user\n        content_type = ContentType.objects.get_for_model(get_user_model())\n        permission = Permission.objects.get(\n            codename = 'view_user',\n            content_type = content_type,\n        )\n\n        self.user_logged_in.user_permissions.add(permission)\n        self.user_logged_in.refresh_from_db()\n\n\nclass UserListGet(UserListWithPermission):\n    def setUp(self):\n        super(UserListGet, self).setUp()\n        get_user_model().objects.create_user(\n            username = 'user1',\n            email = 'user1@domain.com',\n            password = 'user1password',\n            first_name = 'User',\n            last_name = 'One'\n        )\n        get_user_model().objects.create_user(\n            username = 'user2',\n            email = 'user2@domain.com',\n            password = 'user2password',\n            first_name = 'User',\n            last_name = 'Two'\n        )\n        self.response = self.client.get(r('accounts:user-list'))\n\n    def test_get(self):\n        self.assertEqual(200, self.response.status_code)\n\n    def test_template(self):\n        self.assertTemplateUsed(self.response, 'accounts/user/list.html')\n\n    def test_html(self):\n        contents = [\n            (1, 'User One'),\n            (1, 'user1@domain.com'),\n            (1, 'User Two'),\n            (1, 'user2@domain.com'),\n            # Must have a link to create a new user.\n            (1, 'href=\"{}\"'.format(r('accounts:user-create'))),\n        ]\n\n        for count, expected in contents:\n            with self.subTest():\n                self.assertContains(self.response, expected, count)\n\n    def test_context(self):\n        variables = ['users']\n\n        for key in variables:\n            with self.subTest():\n                self.assertIn(key, self.response.context)\n"
    },
    {
        "case number": "35",
        "code": "def max_dict(dictionnaire):\n    \"\"\"Retourne la valeur maximale d'un dictionnaire\"\"\"\n    \n    max_value = 0\n    for i, value in enumerate(dictionnaire.values()):\n        if i == 0 or value > max_value:\n            max_value = value\n\n    return max_value\n\n",
        "unittest": "from max_dict import max_dict\n\n\n\ndef test_max_dict():\n\n    #Argent de poche\n    dictionnaire = {\"Alfred\" : 100, \"Julie\" : 150, \"Antoine\" : 20}\n    print(max_dict(dictionnaire))\n\n    #Magasin de luxe\n    luxe = {\"Bague\" : 3200, \"Montre\" : 5600, \"Sac \u00e0 main\" : 1400}\n    print(max_dict(luxe))\n\n\n\ntest_max_dict()\n\n"
    },
    {
        "case number": "36",
        "code": "def fizz_buzz(value):\n    if(value % 3 == 0 and value % 5 == 0):\n        return \"FizzBuzz\"\n    elif (value % 3 == 0):\n        return \"Fizz\"\n    elif(value % 5 == 0):\n        return \"Buzz\"\n    else:\n        return value\n",
        "unittest": "import pytest\n\ndef fizz_buzz(value):\n    if(value % 3 == 0 and value % 5 == 0):\n        return \"FizzBuzz\"\n    elif (value % 3 == 0):\n        return \"Fizz\"\n    elif(value % 5 == 0):\n        return \"Buzz\"\n    else:\n        return value\n\n \n@pytest.mark.parametrize(\"input\", [3,6,9,12,18,21,24,27,33,36,39,42,48])  \n# @pytest.mark.parametrize(\"input\", [3,6,9,12,18,21,24,27,30,33,36,39,42,45,48])  \ndef test_multiples_of_3_return_Fizz(input):    \n    assert \"Fizz\" == fizz_buzz(input)\n    \n@pytest.mark.parametrize(\"input\", [15,30,45])  \ndef test_multiples_of_3_and_5_return_FizzBuzz(input):    \n    assert \"FizzBuzz\" == fizz_buzz(input)\n    \n@pytest.mark.parametrize(\"input\", [5,10,20,25,35,40,50])  \ndef test_multiples_of_5_return_Buzz(input):    \n    assert \"Buzz\" == fizz_buzz(input)\n    \n@pytest.mark.parametrize(\"input\", [1,2,4,7,8,11,13,14,16,17,19,22,23,26,28,29,31,32,34,37,38,41,43,44,46,47,49])  \ndef test_otherwise_returns_input(input):    \n    assert input == fizz_buzz(input)\n    \n    \n@pytest.mark.parametrize(\"input, expected\",\n                         [(1, 1),\n                          (2, 2),\n                          (3, \"Fizz\"),\n                          (4, 4),\n                          (5, \"Buzz\"),\n                          (15,\"FizzBuzz\")])\ndef test_multiple_inputs(input, expected):\n    assert expected == fizz_buzz(input)\n    print(f\"{input}: {expected}\")\n"
    },
    {
        "case number": "37",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "38",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "39",
        "code": "def is_prime(number):\n    if number < 0 or number in (0, 1):\n        return False\n\n    for element in range(2, number):\n        if number % element == 0:\n            return False\n\n    return True\n\n",
        "unittest": "import pytest\n\nfrom primes import is_prime\n\n\n@pytest.fixture()\ndef prime_numbers():\n    return [3, 5, 7]\n\n\n@pytest.fixture()\ndef non_prime_numbers():\n    return [8, 0, 1]\n\n\n@pytest.fixture()\ndef negative_numbers():\n    return [-1, -3, -6]\n\n\ndef test_is_prime_true(prime_numbers):\n    for number in prime_numbers:\n        assert is_prime(number)\n\n\ndef test_is_prime_false(non_prime_numbers, negative_numbers):\n    for number in non_prime_numbers:\n        assert not is_prime(number)\n\n    for number in negative_numbers:\n        assert not is_prime(number)\n\n"
    },
    {
        "case number": "40",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "41",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "42",
        "code": "def add_one(number):\n    return number + 1\n",
        "unittest": "# the inclusion of the tests module is not meant to offer best practices for\n# testing in general, but rather to support the `find_packages` example in\n# setup.py that excludes installing the \"tests\" package\n\nimport unittest\n\nfrom sample.simple import add_one\n\n\nclass TestSimple(unittest.TestCase):\n\n    def test_add_one(self):\n        self.assertEqual(add_one(5), 6)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\n"
    },
    {
        "case number": "43",
        "code": "def getPairsCount(arr, n, sum):      \n    count, s = 0, {}\n    for i in range(0, n): \n        temp = sum-arr[i] \n        if (temp in s): \n            count += s[temp]\n        if arr[i] not in s:\n        \ts[arr[i]] = 1\n        else:\n        \ts[arr[i]] += 1\n    return count\n\nprint(getPairsCount([1, 1, 1, 1, 1], 5, 2))\n",
        "unittest": "MAX = 100000\nprime = [True for i in range(MAX + 1)]\nappend_prime = []\ndef Sieve(): \n    prime[1] = False\n    for p in range(2, MAX+1):  \n        if (prime[p] == True):\n            i = p * 2\n            while(i <= MAX): \n                prime[i] = False\n                i = i + p\n    prev = 0\n    for i in range(MAX+1):\n        if prime[i]:\n            append_prime.append(i+prev)\n            prev = append_prime[-1]\n\nq= int(input())\nSieve()\nfor i in range(q):\n    n = int(input())\n    print(append_prime[n])\n"
    },
    {
        "case number": "44",
        "code": "DIGITS = '0123456789abcdef'\n\n\ndef convert_to_base(decimal_number, base):\n    remainder_stack = []\n\n    while decimal_number > 0:\n        remainder = decimal_number % base\n        remainder_stack.append(remainder)\n        decimal_number = decimal_number // base\n\n    new_digits = []\n    while remainder_stack:\n        new_digits.append(DIGITS[remainder_stack.pop()])\n\n    return ''.join(new_digits)\n\n\nconvert_to_base(25, 2)  # => '11001'\nconvert_to_base(25, 16)  # => '19'\n\n",
        "unittest": "import unittest\n\nfrom base_conversion import convert_to_base\n\n\nclass TestCorrectness(unittest.TestCase):\n\n    def assert_matches_format_builtin(self, base, format_string):\n        for i in range(1, 100):\n            self.assertEqual(convert_to_base(i, base), format_string.format(i))\n\n    def test_converts_to_binary(self):\n        self.assert_matches_format_builtin(2, '{0:b}')\n\n    def test_converts_to_octal(self):\n        self.assert_matches_format_builtin(8, '{0:o}')\n\n    def test_converts_to_hex(self):\n        self.assert_matches_format_builtin(16, '{0:x}')\n\n\nif __name__ == '__main__':\n    unittest.main()\n\n"
    },
    {
        "case number": "45",
        "code": "def hypotenuse(a, b):\n    \"\"\"Calcule la valeur de l'hypot\u00e9nuse d'un triangle rectangle\"\"\"\n\n    return (a**2 + b**2)**0.5\n\n",
        "unittest": "from hypotenuse import hypotenuse\n\na, b = 3, 4\nprint(hypotenuse(a,b))\n\na, b = 5, 6\nprint(hypotenuse(a,b))\n\na, b = 1, 2\nprint(hypotenuse(a,b))\n\na, b = 1, 50\nprint(hypotenuse(a,b))\n\n"
    },
    {
        "case number": "46",
        "code": "def fib(n):\n    assert 0 <= n <= 10 ** 7\n\n    if n <= 1:\n        return n\n    else:\n        fib_list = [0] * (n+1)\n        fib_list[0] = 0\n        fib_list[1] = 1\n        for i in range(2, n+1):\n            fib_list[i] = (fib_list[i-2] + fib_list[i-1]) % 10\n        return fib_list[n]\n\n\nif __name__ == '__main__':\n    input_n = int(input())\n    print(fib(input_n))\n",
        "unittest": "import unittest\nimport fibboaaci\n\nclass TestLastDigitOfFibonacciNumber(unittest.TestCase):\n    def test_small(self):\n        for n in range(20):\n            self.assertEqual(last_digit_of_fibonacci_number_naive(n),\n                             last_digit_of_fibonacci_number(n))\n\n    def test_large(self):\n        for (n, last_digit) in [(100, 5), (139, 1), (91239, 6), (170, 5)]:\n            self.assertEqual(last_digit_of_fibonacci_number(n), last_digit)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"
    },
    {
        "case number": "47",
        "code": "from toolz import curry\n\n\n@curry\ndef median(xs):\n    \"\"\"Returns the median of the given list of numbers\"\"\"\n    _xs = sorted(xs)\n    n = len(xs)\n    i = n // 2\n    if n < 1:\n        return None\n\n    if n % 2 == 0:\n        return (_xs[i - 1] + _xs[i]) / 2.0\n\n    return _xs[i]\n\n",
        "unittest": "from ramda.median import median\nfrom ramda.private.asserts import assert_equal\n\n\ndef test_median():\n    assert_equal(median([2, 9, 7]), 7)\n    assert_equal(median([7, 2, 10, 9]), 8)\n    assert_equal(median([]), None)\n\n"
    },
    {
        "case number": "48",
        "code": "from collections import deque\n\n\ndef is_palindrome(characters):\n    character_deque = deque(characters)\n\n    while len(character_deque) > 1:\n        first = character_deque.popleft()\n        last = character_deque.pop()\n        if first != last:\n            return False\n\n    return True\n\n\nis_palindrome('lsdkjfskf')   # => False\nis_palindrome('radar')   # => True\n\n",
        "unittest": "import unittest\n\nfrom palindromes import is_palindrome\n\ncases = (\n    ('lsdkjfskf', False),\n    ('radar', True),\n    ('racecar', True),\n)\n\n\nclass TestCorrectness(unittest.TestCase):\n    def test_identifies_palindromes(self):\n        for word, expectation in cases:\n            self.assertEqual(is_palindrome(word), expectation)\n\n"
    },
    {
        "case number": "49",
        "code": "\"\"\"\nProblem: https://en.wikipedia.org/wiki/Modular_exponentiation\n\"\"\"\n\ndef modular_exponentiation(base, exp, mod):\n\tif exp < 1:\n\t\traise ValueError(\"Exponentiation should be ve+ int\")\n\tif mod == 1:\n\t\treturn 0\n\telif mod < 1:\n\t\traise ValueError(\"Modulus should be ve+ int\")\n\t#Initialize result to 1\n\tresult = 1\n\tbase %= mod\n\twhile exp > 0:\n\t\t#multiply base to result if exp is odd\n\t\tif exp % 2 == 1:\n\t\t\tresult = (result * base) % mod\n\t\t#Double base and half exp\n\t\texp = exp >> 1\n\t\tbase = (base ** 2) % mod\n\treturn result\n",
        "unittest": "import os, sys\nimport unittest\nsys.path.append(os.path.join(os.getcwd(), os.path.pardir))\nfrom misc import modular_exponentiation as me\n\nclass TestLCS(unittest.TestCase):\n    def test_modular_exponentiation(self):\n    \tself.assertEqual(me.modular_exponentiation(2, 10, 100), 24)\n    \tself.assertEqual(me.modular_exponentiation(2, 200, 10), 6)\n    \tself.assertEqual(me.modular_exponentiation(5, 20, 1), 0)\n    \t#self.assertEqual(me.modular_exponentiation(8, 1, 10), 8)\n    \tself.assertRaises(ValueError, me.modular_exponentiation, 12, -1, 10)\n    \tself.assertRaises(ValueError, me.modular_exponentiation, 12, 5, 0)\n\nif __name__ == \"__main__\":\n    unittest.main()\n"
    }
]