[
    {
        "case number": "110",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "111",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "112",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "113",
        "code": "from typing import Union\n\nfrom .utils.to_int import to_int\n\n\ndef is_odd(input: Union[int, str]) -> bool:\n    input = to_int(input)\n\n    if input is None:\n        return False\n\n    return bool(input % 2)\n\n",
        "unittest": "import unittest\n\nfrom pyvalidator.is_odd import is_odd\nfrom . import print_test_ok\n\n\nclass TestIsOdd(unittest.TestCase):\n    def valid_check(self, items):\n        for item in items:\n            try:\n                self.assertTrue(is_odd(item))\n            except Exception as e:\n                print(f'failed for input: {item}')\n                raise e\n\n    def invalid_check(self, items):\n        for item in items:\n            try:\n                self.assertFalse(is_odd(item))\n            except Exception as e:\n                print(f'failed for input: {item}')\n                raise e\n\n    def test_valid_odd(self):\n        valid_items = [\n            1,\n            3,\n            5,\n            7,\n            9,\n            111,\n            2019,\n            -1\n        ]\n        self.valid_check(valid_items)\n        print_test_ok()\n\n    def test_invalid_odd(self):\n        invalid_items = [\n            ' ',\n            'a',\n            '.1',\n            '1.1',\n            0,\n            2,\n            110,\n            220,\n            2020,\n            '2020',\n            '666',\n            '2',\n            '0'\n        ]\n        self.invalid_check(invalid_items)\n        print_test_ok()\n\n"
    },
    {
        "case number": "114",
        "code": "# coding: utf-8\n\"\"\"\nhttps://leetcode.com/problems/maximum-subarray/\n\"\"\"\nfrom typing import List\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        max_sum = current_sum = nums[0]\n        for num in nums[1:]:\n            current_sum = current_sum + num\n\n            # if the current sum is less than the current num\n            # there is no reason to continue to sum\n            if current_sum < num:\n                current_sum = num\n\n            if current_sum > max_sum:\n                max_sum = current_sum\n\n        return max_sum\n\n",
        "unittest": "# coding: utf-8\nimport unittest\n\nfrom problems.maximum_subarray import Solution\n\n\nclass TestCase(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test(self):\n        nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n        self.assertEqual(self.solution.maxSubArray(nums), 6)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\n"
    },
    {
        "case number": "115",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "116",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "117",
        "code": "#\n\nimport inflect\n\np = inflect.engine()\n\n\ndef select_uppercase(s):\n    return s.upper()\n\ndef select_article(s):\n    return p.an(s)\n\n\ndef select_pluralize(subject, count):\n    return p.plural(subject, count)\n\n\ndef select_plural_verb(verb, subject):\n    return p.plural_verb(verb, subject)\n\n\ndef select_plural_adj(adj, subject):\n    return p.plural_adj(adj, subject)\n\n\ndef select_conjunction(wordlist):\n    \"\"\"Join a list with commas and such.\"\"\"\n    return p.join(wordlist)\n\n",
        "unittest": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"Fully test this module's functionality through the use of fixtures.\"\n#\n\nimport unittest2 as unittest\nfrom megacosm import select_article, select_pluralize, select_conjunction, select_uppercase\nfrom megacosm import select_plural_verb, select_plural_adj\n\n\nclass TestFilter(unittest.TestCase):\n\n    def test_select_uppercase(self):\n        self.assertEquals('DOG', select_uppercase('dog'))\n\n    def test_select_article(self):\n        self.assertEquals('a dog', select_article('dog'))\n        self.assertEquals('an apple', select_article('apple'))\n        self.assertEquals('an hour', select_article('hour'))\n\n    def test_select_pluralize(self):\n        self.assertEquals('dogs', select_pluralize('dog', 0))\n        self.assertEquals('dog', select_pluralize('dog', 1))\n        self.assertEquals('dogs', select_pluralize('dog', 2))\n        self.assertEquals('classes', select_pluralize('class', 0))\n        self.assertEquals('class', select_pluralize('class', 1))\n        self.assertEquals('classes', select_pluralize('class', 2))\n\n    def test_select_conjunction(self):\n        self.assertEquals('a', select_conjunction(['a']))\n        self.assertEquals('a and b', select_conjunction(['a', 'b']))\n        self.assertEquals('a, b, and c', select_conjunction(['a', 'b', 'c']))\n        self.assertEquals('a, b, c, and d', select_conjunction(['a', 'b', 'c', 'd']))\n\n    def test_select_plural_verb(self):\n        self.assertEquals('were', select_plural_verb('was', 0))\n        self.assertEquals('was', select_plural_verb('was', 1))\n        self.assertEquals('were', select_plural_verb('was', 2))\n\n    def test_select_plural_adj(self):\n        self.assertEquals('some', select_plural_adj('a', 0))\n        self.assertEquals('a', select_plural_adj('a', 1))\n        self.assertEquals('some', select_plural_adj('a', 2))\n\n        self.assertEquals('these', select_plural_adj('this', 0))\n        self.assertEquals('this', select_plural_adj('this', 1))\n        self.assertEquals('these', select_plural_adj('this', 2))\n\n        self.assertEquals('those', select_plural_adj('that', 0))\n        self.assertEquals('that', select_plural_adj('that', 1))\n        self.assertEquals('those', select_plural_adj('that', 2))\n\n        self.assertEquals('our', select_plural_adj('my', 0))\n        self.assertEquals('my', select_plural_adj('my', 1))\n        self.assertEquals('our', select_plural_adj('my', 2))\n\n"
    },
    {
        "case number": "118",
        "code": "\"\"\"\nYou get a string and need to return its number of vowels.\nFor this test, we will only consider a, e, i, o and u as vowels.\n\nFor example:\n\nInput: \"Alabama\"\nOutput: 4\n\nInput: \"Caserta\"\nOutput: 3\n\n\"\"\"\n\n\n#For Loop\ndef count(input_string):\n    num_vowels = 0\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    for letter in input_string.lower():\n        if letter in vowels:\n            num_vowels += 1\n\n    return num_vowels\n\n",
        "unittest": "from Company.vowel_count import count\n\n\ndef test_count():\n    assert count('Alabama') == 4\n    assert count('Caserta') == 3\n\n"
    },
    {
        "case number": "119",
        "code": "\"\"\"\nGiven a 32-bit signed integer, reverse digits of an integer.\n\nExample 1:\n\nInput: 123\nOutput: 321\nExample 2:\n\nInput: -123\nOutput: -321\nExample 3:\n\nInput: 120\nOutput: 21\n\"\"\"\n\n\nclass Solution(object):\n    def matchChar(self, sc, pc):\n        return sc == pc or pc == '.'\n\n    def isEndOfStar(self, p):\n        while p != '':\n            if len(p) == 1 or len(p) > 1 and p[1] != '*':\n                return False\n            p = p[2:]\n        return True\n\n    def isMatch(self, s, p):\n        if p == '':\n            return s == ''\n\n        if s == '':\n            return self.isEndOfStar(p)\n\n        if (len(p) > 1 and p[1] != '*') or len(p) == 1:\n            # without *\n            if not self.matchChar(s[0], p[0]):\n                return False\n            else:\n                return self.isMatch(s[1:], p[1:])\n\n        else:\n            # with *\n            # try see x* is empty\n            if self.isMatch(s[0:], p[2:]):\n                return True\n\n            while self.matchChar(s[0], p[0]):\n                s = s[1:]\n\n                if self.isMatch(s, p[2:]):\n                    return True\n\n                if s == '':\n                    return self.isEndOfStar(p)\n            return False\n\n",
        "unittest": "\"\"\"\nTest cases for 7.py found in the LeetCode folder.\nAnswer by @VGZELDA\n\"\"\"\n# function to be tested\ndef reverse(x):\n        x=int(x)\n        if(x>=0):\n            x=str(x)\n            x=x[::-1]\n            x=int(x)\n            if(x<-1*(2**31))or(x>=2**31):\n                return 0\n            else:\n                return x\n        else:\n            x=x*(-1)\n            x=str(x)\n            x=x[::-1]\n            x=int(x)\n            x=-1*x\n            if(x<-1*(2147483648))or(x>=2147483648):\n                return 0\n            else:\n                return x\n# function to test reverse\ndef test_reverse():\n    assert reverse(123) == 321, \"Should be 321\"\n    assert reverse(120) == 21, \"Should be 21\"\ntest_reverse()\nprint(\"Everything passed\")\n\n"
    },
    {
        "case number": "120",
        "code": "import numpy as np\n\n\ndef top_k(a, k, reverse=False):\n    flat = a.ravel()\n\n    if len(flat) <= k:\n        return np.arange(len(a))\n\n    if reverse:\n        top_k_inds = np.argpartition(flat, len(flat)-k)[-k:]\n    else:\n        top_k_inds = np.argpartition(flat, k)[:k]\n\n    return np.unravel_index(top_k_inds, a.shape)\n\n",
        "unittest": "import unittest\nimport numpy as np\n\nfrom collections import Counter\n\nfrom pero_ocr.decoding.multisort import top_k\n\n\nclass MultisortTests(unittest.TestCase):\n    def test_single_elem(self):\n        arr = np.asarray([1])\n        inds = np.asarray([0])\n\n        self.assertEqual(top_k(arr, k=1), inds)\n\n    def test_unique_solution(self):\n        arr = np.asarray([2, 3, 1, 4, 0, 5])\n        inds = np.asarray([4])\n\n        self.assertEqual(top_k(arr, k=1), inds)\n\n    def test_simple_2d(self):\n        arr = np.asarray([[2, 3, 1], [4, 0, 5]])\n        retval = top_k(arr, k=1)\n\n        self.assertEquals(arr[retval], 0)\n\n    def test_k2_2d(self):\n        arr = np.asarray([[2, 3, 1], [4, 0, 5]])\n        retval = top_k(arr, k=2)\n\n        self.assertEquals(set(arr[retval].tolist()), set([0, 1]))\n\n    def test_k2_2d_reverse(self):\n        arr = np.asarray([[2, 3, 1], [4, 0, 5]])\n        retval = top_k(arr, k=2, reverse=True)\n\n        self.assertEquals(set(arr[retval].tolist()), set([4, 5]))\n\n    def test_k2_2d_reverse_duplicit_top(self):\n        arr = np.asarray([[2, 5, 1], [4, 0, 5]])\n        retval = top_k(arr, k=2, reverse=True)\n\n        self.assertEquals(Counter(arr[retval].tolist()), Counter([5, 5]))\n\n"
    },
    {
        "case number": "121",
        "code": "class Solution:\n    def arraySign(self, nums: List[int]) -> int:\n        prod = 1\n\t\t\n        for i in range(len(nums)):\n            prod *= nums[i]\n            \n        if prod > 0:\n            return 1\n        elif prod == 0:\n            return 0\n        else:\n            return -1\n\t\t\t\n\t\t\t\t\n#Second solution\nclass Solution:\n    def arraySign(self, nums: List[int]) -> int:\n        if 0 in nums:\n            return 0\n\t\t\t\n        count = 0\n        for i in nums:\n            if i < 0:\n                count += 1\n        return 1 if count%2 == 0 else -1\n            \n",
        "unittest": "class Solution:\n    def arraySign(self, nums: List[int]) -> int:\n        prod = 1\n\t\t\n        for i in range(len(nums)):\n            prod *= nums[i]\n            \n        if prod > 0:\n            return 1\n        elif prod == 0:\n            return 0\n        else:\n            return -1\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\nclass Solution:\n    def arraySign(self, nums: List[int]) -> int:\n        if 0 in nums:\n            return 0\n\t\t\t\n        count = 0\n        for i in nums:\n            if i < 0:\n                count += 1\n        return 1 if count%2 == 0 else -1\n            \n"
    },
    {
        "case number": "122",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "123",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "124",
        "code": "\n\ndef is_year_leap(year):\n\n    if year % 400 == 0:\n        return True\n\n    if year % 4 == 0 and year % 100 != 0:\n        return True\n\n    return False\n\n\ndef date(day, month, year):\n    day_in_month = {1: 31,\n                    2: 29 if is_year_leap(year) else 28,\n                    3: 31,\n                    4: 30,\n                    5: 31,\n                    6: 30,\n                    7: 31,\n                    8: 31,\n                    9: 30,\n                    10: 31,\n                    11: 30,\n                    12: 31}\n\n    if 1 <= month <= 12 and 1 <= day <= day_in_month[month]:\n        return True\n    return False\n\n\ndef date_cheat(day, month, year):\n    \"\"\"\u041f\u0440\u043e\u0449\u0435, \u043d\u043e \u044d\u0442\u043e \u043d\u0435\u043f\u0435\u0434\u0430\u0433\u043e\u0433\u0438\u0447\u043d\u043e :)\"\"\"\n    import datetime\n    try:\n        datetime.date(year, month, day)\n    except ValueError:\n        return False\n    else:\n        return True\n\n",
        "unittest": "\nimport unittest\n\n\nclass DateTestCase(unittest.TestCase):\n\n    def test_leap_years(self):\n\n        for year in (2000, 2016, 1916):\n            with self.subTest(year=year):\n                self.assertTrue(date(29, 2, year),\n                                \"{} \u0432\u0438\u0441\u043e\u043a\u043e\u0441\u043d\u044b\u0439\".format(year))\n\n        for year in (1900, 2014, 2001):\n            with self.subTest(year=year):\n                self.assertFalse(date(29, 2, year),\n                                 \"{} \u043d\u0435 \u0432\u0438\u0441\u043e\u043a\u043e\u0441\u043d\u044b\u0439\".format(year))\n\n    def test_valid_dates(self):\n\n        self.assertTrue(date(1, 1, 1900))\n        self.assertTrue(date(28, 2, 1900))\n        self.assertTrue(date(1, 1, 1))\n        self.assertTrue(date(31, 1, 2000))\n        self.assertTrue(date(31, 12, 1900))\n\n    def test_invalid_month(self):\n\n        self.assertFalse(date(1, 13, 1900))\n        self.assertFalse(date(2, 14, 2003))\n\n    def test_invalid_day(self):\n\n        self.assertFalse(date(32, 1, 1900))\n        self.assertFalse(date(30, 2, 1900))\n        self.assertFalse(date(31, 4, 1900))\n\n    def test_invalid_all(self):\n\n        self.assertFalse(date(32, 13, 1900))\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"
    },
    {
        "case number": "125",
        "code": "import re\n\nfrom typing import List\n\n\ndef is_camel_case_word(word: str) -> bool:\n    uppercase_letters_amount = re.subn(r'[A-Z]', '', word)[1]\n    lowercase_letters_amount = re.subn(r'[a-z]', '', word)[1]\n    return bool(\n        (lowercase_letters_amount and uppercase_letters_amount >= 2)\n        or re.findall(r'[a-z][A-Z]', word),\n    )\n\n\ndef split_camel_case_words(camel_cased_word: str) -> List[str]:\n    words_start_indexes = [m.start(0) for m in re.finditer(r'[A-Z]', camel_cased_word)]\n    if words_start_indexes[0] > 0:\n        words_start_indexes.insert(0, 0)\n    if words_start_indexes[-1] < len(camel_cased_word):\n        words_start_indexes.append(len(camel_cased_word))\n    words = []\n    for word_start_index, word_end_index in zip(words_start_indexes, words_start_indexes[1:]):\n        words.append(camel_cased_word[word_start_index:word_end_index].lower())\n    return words\n\n",
        "unittest": "from rozental_as_a_service.text_utils import is_camel_case_word, split_camel_case_words\n\n\ndef test_is_camel_case_word():\n    assert is_camel_case_word('Notcamelcase') is False\n    assert is_camel_case_word('IsCamelCase') is True\n\n\ndef test_split_camel_case_words():\n    assert split_camel_case_words('ReturnNormalWorlds') == ['return', 'normal', 'worlds']\n\n"
    },
    {
        "case number": "126",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "127",
        "code": "def is_prime(number):\n    if number < 0 or number in (0, 1):\n        return False\n\n    for element in range(2, number):\n        if number % element == 0:\n            return False\n\n    return True\n\n",
        "unittest": "import pytest\n\nfrom primes import is_prime\n\n\n@pytest.fixture()\ndef prime_numbers():\n    return [3, 5, 7]\n\n\n@pytest.fixture()\ndef non_prime_numbers():\n    return [8, 0, 1]\n\n\n@pytest.fixture()\ndef negative_numbers():\n    return [-1, -3, -6]\n\n\ndef test_is_prime_true(prime_numbers):\n    for number in prime_numbers:\n        assert is_prime(number)\n\n\ndef test_is_prime_false(non_prime_numbers, negative_numbers):\n    for number in non_prime_numbers:\n        assert not is_prime(number)\n\n    for number in negative_numbers:\n        assert not is_prime(number)\n\n"
    },
    {
        "case number": "128",
        "code": "class Solution:\n    def arraySign(self, nums: List[int]) -> int:\n        prod = 1\n\t\t\n        for i in range(len(nums)):\n            prod *= nums[i]\n            \n        if prod > 0:\n            return 1\n        elif prod == 0:\n            return 0\n        else:\n            return -1\n\t\t\t\n\t\t\t\t\n#Second solution\nclass Solution:\n    def arraySign(self, nums: List[int]) -> int:\n        if 0 in nums:\n            return 0\n\t\t\t\n        count = 0\n        for i in nums:\n            if i < 0:\n                count += 1\n        return 1 if count%2 == 0 else -1\n            \n",
        "unittest": "class Solution:\n    def arraySign(self, nums: List[int]) -> int:\n        prod = 1\n\t\t\n        for i in range(len(nums)):\n            prod *= nums[i]\n            \n        if prod > 0:\n            return 1\n        elif prod == 0:\n            return 0\n        else:\n            return -1\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\nclass Solution:\n    def arraySign(self, nums: List[int]) -> int:\n        if 0 in nums:\n            return 0\n\t\t\t\n        count = 0\n        for i in nums:\n            if i < 0:\n                count += 1\n        return 1 if count%2 == 0 else -1\n            \n"
    },
    {
        "case number": "129",
        "code": "\"\"\"https://leetcode.com/problems/minimum-path-sum\"\"\"\nimport heapq\n\n\ndef min_path_sum_dp(grid):\n    \"\"\"Solution using dynamic programming.\n\n    Time complexity: O(m * n)\n    Space complexity: O(1)\n\n    Args:\n        grid(List[List[int]]): Matrix m x n filled with non-negative integers.\n\n    Returns:\n        Minimal sum of all numbers of a path (One can only move either down or\n        right at any point in time) from top left to bottom right.\n\n    \"\"\"\n    for x in range(len(grid)):\n        for y in range(len(grid[0])):\n            if x > 0 and y > 0:\n                grid[x][y] = min(\n                    grid[x][y] + grid[x - 1][y],\n                    grid[x][y] + grid[x][y - 1]\n                )\n            elif x > 0:\n                grid[x][y] = grid[x][y] + grid[x - 1][y]\n            elif y > 0:\n                grid[x][y] = grid[x][y] + grid[x][y - 1]\n\n    return grid[len(grid) - 1][len(grid[0]) - 1]\n\n\ndef min_path_sum_djikstra(grid):\n    \"\"\"Solution using Djikstra algorithm.\n\n    Time complexity: O(V + E) where V: vertices, E: edges.\n    Space complexity: O(V)\n\n    Args:\n        grid(List[List[int]]): Matrix m x n filled with non-negative integers.\n\n    Returns:\n        Minimal sum of all numbers of a path (One can only move either down or\n        right at any point in time) from top left to bottom right.\n\n    \"\"\"\n    heap = [(grid[0][0], 0, 0)]\n\n    while heap:\n        cost, x, y = heapq.heappop(heap)\n\n        if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            return cost\n\n        if x < len(grid) - 1:\n            heapq.heappush(heap, (cost + grid[x + 1][y], x + 1, y))\n        if y < len(grid[0]) - 1:\n            heapq.heappush(heap, (cost + grid[x][y + 1], x, y + 1))\n\n",
        "unittest": "import pytest\nfrom dsa.problems.min_path_sum import min_path_sum_dp, min_path_sum_djikstra\n\n\n@pytest.mark.parametrize(\"grid, expected\", [\n    ([[1,3,1],[1,5,1],[4,2,1]], 7),\n    ([[1,2,3],[4,5,6]], 12),\n])\ndef test_min_path_sum_dp(grid, expected):\n    assert min_path_sum_dp(grid) == expected\n\n\n@pytest.mark.parametrize(\"grid, expected\", [\n    ([[1,3,1],[1,5,1],[4,2,1]], 7),\n    ([[1,2,3],[4,5,6]], 12),\n])\ndef test_min_path_sum_djikstra(grid, expected):\n    assert min_path_sum_djikstra(grid) == expected\n\n"
    },
    {
        "case number": "130",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "131",
        "code": "from typing import Union\n\nfrom .utils.to_int import to_int\n\n\ndef is_odd(input: Union[int, str]) -> bool:\n    input = to_int(input)\n\n    if input is None:\n        return False\n\n    return bool(input % 2)\n\n",
        "unittest": "import unittest\n\nfrom pyvalidator.is_odd import is_odd\nfrom . import print_test_ok\n\n\nclass TestIsOdd(unittest.TestCase):\n    def valid_check(self, items):\n        for item in items:\n            try:\n                self.assertTrue(is_odd(item))\n            except Exception as e:\n                print(f'failed for input: {item}')\n                raise e\n\n    def invalid_check(self, items):\n        for item in items:\n            try:\n                self.assertFalse(is_odd(item))\n            except Exception as e:\n                print(f'failed for input: {item}')\n                raise e\n\n    def test_valid_odd(self):\n        valid_items = [\n            1,\n            3,\n            5,\n            7,\n            9,\n            111,\n            2019,\n            -1\n        ]\n        self.valid_check(valid_items)\n        print_test_ok()\n\n    def test_invalid_odd(self):\n        invalid_items = [\n            ' ',\n            'a',\n            '.1',\n            '1.1',\n            0,\n            2,\n            110,\n            220,\n            2020,\n            '2020',\n            '666',\n            '2',\n            '0'\n        ]\n        self.invalid_check(invalid_items)\n        print_test_ok()\n\n"
    },
    {
        "case number": "132",
        "code": "OPENING = '('\n\n\ndef is_balanced(parentheses):\n    stack = []\n    for paren in parentheses:\n        if paren == OPENING:\n            stack.append(paren)\n        else:\n            try:\n                stack.pop()\n            except IndexError:  # too many closing parens\n                return False\n    return len(stack) == 0  # false if too many opening parens\n\n\nis_balanced('((()))')  # => True\nis_balanced('(()')  # => False\nis_balanced('())')  # => False\n\n",
        "unittest": "import unittest\n\nfrom balanced_parentheses import is_balanced\n\n\nclass TestCorrectness(unittest.TestCase):\n\n    def test_identifies_valid_sequence(self):\n        self.assertTrue(is_balanced('()'))\n        self.assertTrue(is_balanced('()(())'))\n\n    def test_identifies_left_imbalance(self):\n        self.assertFalse(is_balanced('(()'))\n\n    def test_identifies_right_imbalance(self):\n        self.assertFalse(is_balanced('())'))\n\n\nif __name__ == '__main__':\n    unittest.main()\n\n"
    },
    {
        "case number": "133",
        "code": "\ndef square(n: float) -> float:\n    \"\"\"Square a number.\"\"\"\n    return n**2\n\n",
        "unittest": "from .squarer import square\n\n\ndef test_square():\n    # When\n    subject = square(4)\n\n    # Then\n    assert subject == 16\n\n"
    },
    {
        "case number": "134",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "135",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "136",
        "code": "\"\"\"eetcode.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves\"\"\"\n\n\ndef min_difference(nums):\n    \"\"\"\n    Time complexity: O(log(n))\n    Space complexity: O(1)\n\n    Args:\n        nums(List[int]): An array of numbers\n\n    Returns:\n        The minimum difference between the largest and smallest value of nums\n        after perfoming at most 3 moves.\n\n    \"\"\"\n    if len(nums) <= 4:\n        return 0\n\n    nums.sort()\n    return min(\n        (nums[-1] - nums[3]),\n        (nums[-2] - nums[2]),\n        (nums[-3] - nums[1]),\n        (nums[-4] - nums[0]),\n    )\n\n",
        "unittest": "import pytest\nfrom dsa.problems.min_difference import min_difference\n\n\n@pytest.mark.parametrize(\"nums, expected\", [\n    ([5,3,2,4], 0),\n    ([1,5,0,10,14], 1),\n    ([6,6,0,1,1,4,6], 2),\n    ([1,5,6,14,15], 1),\n    ([1,2], 0),\n    ([20,66,68,57,45,18,42,34,37,58], 31),\n    ([82,81,95,75,20], 1),\n])\ndef test_min_difference(nums, expected):\n    assert min_difference(nums) == expected\n\n"
    },
    {
        "case number": "137",
        "code": "\"\"\"A version utility module.\"\"\"\n\n\ndef cmp(a: int | str, b: int | str) -> int:\n    \"\"\"\n    C style cmp function returning the compare result as int.\n\n    Compare the two objects a and b and return an integer according to\n    the outcome. The return value is negative if x < b, zero if a == b\n    and strictly positive if a > b.\n\n    Parameters\n    ----------\n    a: any\n        First input to compare\n    b: any\n        Second input to compare\n\n    Returns\n    -------\n    int\n        -1 if 'b' is greater\n         0 if both are equal\n         1 if 'a' is greater\n    \"\"\"\n    return int(str(a) > str(b)) - int(str(a) < str(b))\n\n",
        "unittest": "\"\"\"Tests for repod.version.util.\"\"\"\nfrom pytest import mark\n\nfrom repod.version.util import cmp\n\n\n@mark.parametrize(\n    \"first, second, expectation\",\n    [\n        (\"1\", \"1\", 0),\n        (\"1\", \"2\", -1),\n        (\"11\", \"12\", -1),\n        (\"2\", \"1\", 1),\n        (\"a\", \"a\", 0),\n        (\"a\", \"b\", -1),\n        (\"b\", \"a\", 1),\n        (\"aa\", \"ab\", -1),\n        (1, 1, 0),\n        (1, 2, -1),\n        (2, 1, 1),\n        (12, 11, 1),\n    ],\n)\ndef test_cmp(first: int | str, second: int | str, expectation: int) -> None:\n    \"\"\"Test repod.version.util.cmp.\"\"\"\n    assert cmp(first, second) == expectation  # nosec: B101\n\n"
    },
    {
        "case number": "138",
        "code": "from typing import Union\n\nfrom .utils.to_int import to_int\n\n\ndef is_even(input: Union[int, str]) -> bool:\n    input = to_int(input)\n\n    if input is None:\n        return False\n\n    return not bool(input % 2)\n\n",
        "unittest": "import unittest\n\nfrom pyvalidator.is_even import is_even\nfrom . import print_test_ok\n\n\nclass TestIsEven(unittest.TestCase):\n    def valid_check(self, items):\n        for item in items:\n            try:\n                self.assertTrue(is_even(item))\n            except Exception as e:\n                print(f'failed for input: {item}')\n                raise e\n\n    def invalid_check(self, items):\n        for item in items:\n            try:\n                self.assertFalse(is_even(item))\n            except Exception as e:\n                print(f'failed for input: {item}')\n                raise e\n\n    def test_valid_even(self):\n        valid_items = [\n            0,\n            2,\n            4,\n            6,\n            8,\n            10,\n            12,\n            120,\n            1000,\n            -1000,\n            '1000',\n            '2',\n            '120',\n            '666',\n            '-888'\n        ]\n        self.valid_check(valid_items)\n        print_test_ok()\n\n    def test_invalid_even(self):\n        invalid_items = [\n            ' ',\n            'a',\n            '.1',\n            '1.0',\n            3,\n            5,\n            111,\n            -7,\n            '17',\n            '-21',\n            '121'\n        ]\n        self.invalid_check(invalid_items)\n        print_test_ok()\n\n"
    },
    {
        "case number": "139",
        "code": "def fact(x):\n    x_fact = 1\n    for i in range(1, x+1):\n        x_fact *= i\n    return x_fact\n\n",
        "unittest": "import mymath\n\ndef test_math():\n    assert mymath.add(2, 3)  == 5\n    assert mymath.div(6, 3)  == 2\n    assert mymath.div(42, 1) == 42\n    assert mymath.add(-1, 1) == 0\n\n"
    },
    {
        "case number": "140",
        "code": "\"\"\"functions passed to the templates, that cam be used there\n\"\"\"\n\n\ndef addLineBreakToDescription(textLine, indent=0, prefix=''):\n    indentStr = (' ' * indent if indent > 0 else '') + prefix\n    breakedText = prefix\n    currentLen = 0\n    splittedLine = textLine.split()\n    for t in splittedLine:\n        # print('currentLen=' + str(currentLen))\n        if currentLen > 60:\n            currentLen = 0\n            breakedText = breakedText + '\\n' + indentStr\n        elif currentLen > 0:\n            # add space in-between the previous and the current token\n            breakedText = breakedText + ' '\n        currentLen = currentLen + len(t)\n        breakedText = breakedText + t\n    return breakedText\n\n",
        "unittest": "import unittest\n\nimport yacg.templateHelper as templateHelper\n\n\n# For executing these test run: python -m unittest -v tests/model/test_templateHelper.py\nclass TestTemplateHelper (unittest.TestCase):\n\n    def testAddLineBreakToDesc(self):\n        input = 'abc def'\n\n        act = templateHelper.addLineBreakToDescription(input, 0)\n        self.assertEqual(act, 'abc def')\n\n        act = templateHelper.addLineBreakToDescription(input, 4)\n        self.assertEqual(act, 'abc def')\n\n        act = templateHelper.addLineBreakToDescription(input, 0, '// ')\n        self.assertEqual(act, '// abc def')\n\n        act = templateHelper.addLineBreakToDescription(input, 4, '// ')\n        self.assertEqual(act, '// abc def')\n\n        # line break is inserted when token starts after more than 60 (none white space) characters were already processed\n        input = '0123456789 0123456789 0123456789 0123456789 0123456789 0123456789abc 0123456789'\n        act = templateHelper.addLineBreakToDescription(input, 0)\n        self.assertEqual(act, '0123456789 0123456789 0123456789 0123456789 0123456789 0123456789abc\\n0123456789')\n\n        act = templateHelper.addLineBreakToDescription(input, 4)\n        self.assertEqual(act, '0123456789 0123456789 0123456789 0123456789 0123456789 0123456789abc\\n    0123456789')\n\n        input = '0123456789 0123456789 0123456789 0123456789 0123456789 0123456789abc 0123456789'\n        act = templateHelper.addLineBreakToDescription(input, 0, '// ')\n        self.assertEqual(act, '// 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789abc\\n// 0123456789')\n\n        input = '0123456789 0123456789 0123456789 0123456789 0123456789 0123456789abc 0123456789'\n        act = templateHelper.addLineBreakToDescription(input, 4, '// ')\n        self.assertEqual(act, '// 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789abc\\n    // 0123456789')\n\n"
    },
    {
        "case number": "141",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "142",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "143",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "144",
        "code": "def add(a, b):\n    return a + b\n\n\ndef subtract(a, b):\n    return a - b\n\n\ndef multiply(a, b):\n    return a * b\n\n\ndef divide(numerator, denominator):\n    return float(numerator) / denominator\n",
        "unittest": "# test_mymath.py\nimport mymath\nimport unittest\n\nclass TestAdd(unittest.TestCase):\n    \"\"\"\n    Test the add function from the mymath library\n    \"\"\"\n\n    def test_add_integers(self):\n        \"\"\"\n        Test that the addition of two integers returns the correct total\n        \"\"\"\n        result = mymath.add(1, 2)\n        self.assertEqual(result, 3)\n\n    def test_add_floats(self):\n        \"\"\"\n        Test that the addition of two floats returns the correct result\n        \"\"\"\n        result = mymath.add(10.5, 2)\n        self.assertEqual(result, 12.5)\n\n    def test_add_strings(self):\n        \"\"\"\n        Test the addition of two strings returns the two string as one\n        concatenated string\n        \"\"\"\n        result = mymath.add('abc', 'def')\n        self.assertEqual(result, 'abcdef')\n\n\nif __name__ == '__main__':\n    unittest.main()\n"
    },
    {
        "case number": "145",
        "code": "class Solution:\n    def addDigits(self, num: int) -> int:\n        if num < 10:\n            return num\n\n        new_num = 0\n        while num > 0:\n            new_num += num % 10\n            num //= 10\n\n        return self.addDigits(new_num)\n\n",
        "unittest": "from typing import List\n\n\nclass Solution:\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\n        answer = 0\n        double_nums = [num * 2 for num in nums]\n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                if double_nums[i] <= nums[j]:\n                    answer += 1\n\n        return answer\n\n# WA\n# [1,78,27,48,14,86,79,68,77,20,57,21,18,67,5,51,70,85,47,56,22,79,41,8,39,81,59,74,14,45,49,15,10,28,16,77,22,65,8,36,79,94,44,80,72,8,96,78,39,92,69,55,9,44,26,76,40,77,16,69,40,64,12,48,66,7,59,10]\n# output: 1153\n# expected: 64\n\n"
    },
    {
        "case number": "146",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "147",
        "code": "\"\"\"https://leetcode.com/problems/maximal-square\"\"\"\n\n\ndef maximal_square(matrix):\n    \"\"\"\n    Time complexity: O(m * n)\n    Space complexity: O(1)\n\n    Args:\n        matrix(List[List[str]]): m x n binary matrix filled with 0's and 1's.\n\n    Returns:\n        Area of the largest square containing only 1's.\n\n    \"\"\"\n    matrix = [[int(val) for val in row] for row in matrix]\n    max_a = max(\n        max(matrix[0]),\n        max(matrix[x][0] for x in range(len(matrix)))\n    )\n\n    for i in range(1, len(matrix)):\n        if 1 not in matrix[i]:\n            continue\n\n        for j in range(1, len(matrix[0])):\n            if matrix[i][j] == 1:\n                matrix[i][j] = 1 + min(\n                    matrix[i - 1][j],\n                    matrix[i][j - 1],\n                    matrix[i - 1][j - 1]\n                )\n\n                max_a = max(max_a, matrix[i][j])\n\n    return max_a ** 2\n\n",
        "unittest": "import pytest\nfrom dsa.problems.maximal_square import maximal_square\n\n\n@pytest.mark.parametrize(\"matrix, expected\", [\n    ([[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]], 4),\n    ([[\"0\",\"1\"],[\"1\",\"0\"]], 1)\n])\ndef test_maximal_square(matrix, expected):\n    assert maximal_square(matrix) == expected\n\n"
    },
    {
        "case number": "148",
        "code": "\n__all__ = ['get_planet', 'get_all_planets', 'locate_planet']\n\n\nfrom pylightcurve.errors import *\nfrom pylightcurve.__databases__ import plc_data\nfrom pylightcurve.models.exoplanet import Planet\nfrom pylightcurve.spacetime.angles import Degrees, Hours, _request_angle\nfrom pylightcurve.spacetime.targets import FixedTarget\n\n\ndef _flat_name(name):\n\n    flat_name_list = [\n        [' ', ''],\n        ['-', ''],\n        ['cancri', 'cnc'],\n        ['hatp10', 'wasp11'],\n        ['wasp40', 'hatp27'],\n        ['wasp51', 'hatp30'],\n        ['wasp86', 'kelt12'],\n        ['kelt22', 'wasp173'],\n    ]\n\n    name = name.lower()\n\n    for char in flat_name_list:\n        name = name.replace(char[0], char[1])\n\n    return name\n\n\ndef _search_by_planet(name):\n\n    planets = plc_data.ecc()['planets']\n\n    name_or = name\n\n    if name in planets:\n        return name\n\n    else:\n        for i in planets:\n            if _flat_name(i) == _flat_name(name):\n                return str(i)\n            elif (_flat_name(i)[-1] == _flat_name(name)[-1] and _flat_name(i)[:-2] == _flat_name(name)[:-1] and\n                  _flat_name(i)[-2] in ['a', 'b', 'n']):\n                return str(i)\n\n    raise PyLCInputError('No planet {0} found in the catalogue.'.format(name_or))\n\n\ndef get_all_planets():\n\n    return list(plc_data.ecc()['planets'].keys())\n\n\ndef get_planet(name):\n\n    name = _search_by_planet(name)\n\n    planet_data = plc_data.ecc()['planets'][name]\n    star_data = plc_data.ecc()['stars'][planet_data['star']]\n\n    planet = Planet(\n        name,\n        Hours(star_data['ra']),\n        Degrees(star_data['dec']),\n        planet_data['logg'],\n        planet_data['teff'],\n        planet_data['meta'],\n        planet_data['rp_over_rs'],\n        planet_data['ephem_period'],\n        planet_data['sma_over_rs'],\n        planet_data['eccentricity'],\n        planet_data['inclination'],\n        planet_data['periastron'],\n        planet_data['ephem_mid_time'],\n        'BJD_TDB',\n    )\n\n    planet.all_data = {'planet': planet_data, 'star': star_data}\n\n    return planet\n\n\ndef locate_planet(ra, dec, radius=Degrees(0, 1, 0)):\n\n    if isinstance(ra, float):\n        ra = Degrees(ra)\n    else:\n        _request_angle(ra)\n\n    if isinstance(dec, float):\n        dec = Degrees(dec)\n    else:\n        _request_angle(dec)\n\n    if isinstance(radius, float):\n        radius = Degrees(radius)\n    else:\n        _request_angle(radius)\n\n    pointing = FixedTarget(ra, dec)\n\n    test_planets = []\n\n    for test_planet_name in get_all_planets():\n        test_planet = get_planet(test_planet_name).target\n        test_planets.append([pointing.distance_on_sphere(test_planet).deg(), test_planet_name])\n\n    test_planets.sort()\n\n    if test_planets[0][0] < radius.deg():\n        return get_planet(test_planets[0][1])\n    else:\n        raise PyLCLibraryError('Planet could not be located')\n\n",
        "unittest": "\nimport pytest\nimport pylightcurve as plc\n\n\ndef test_catalogues():\n\n    planet1 = plc.get_planet('hatp7b')\n    planet2 = plc.get_planet('HAT-P-7b')\n    assert planet1.name == 'HAT-P-7b'\n    assert planet2.name == 'HAT-P-7b'\n    assert planet1.sma_over_rs == planet2.sma_over_rs\n\n    planet = plc.get_planet('wasp77b')\n    assert planet.name == 'WASP-77Ab'\n\n    with pytest.raises(plc.PyLCInputError):\n        planet = plc.get_planet('aaaaaaaaaa')\n\n    assert len(plc.get_all_planets()) > 0\n\n    planet = plc.locate_planet(plc.Degrees(330.795), plc.Degrees(18.884))\n    assert planet.name == 'HD209458b'\n\n    planet = plc.locate_planet(330.795, 18.884)\n    assert planet.name == 'HD209458b'\n\n    with pytest.raises(plc.PyLCLibraryError):\n        planet = plc.locate_planet(plc.Degrees(330.795), plc.Degrees(17.884))\n\n"
    },
    {
        "case number": "149",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "150",
        "code": "def pow1(x, n: int):\n    \"\"\"\n    compute x ^ n\n    \"\"\"\n    if n == 0:\n        return 1\n    square = x * x\n    if n % 2:\n        return pow1(square, n // 2) * x\n    return pow1(square, n // 2)\n\n\ndef pow2(x, n: int):\n    \"\"\"\n    compute x ^ n\n    \"\"\"\n    if n == 0:\n        return 1\n    tmp = pow2(x, n // 2)\n    if n % 2:\n        return tmp * tmp * x\n    return tmp * tmp\n\n",
        "unittest": "import math\nimport random\nfrom unittest import TestCase\nfrom pow import pow1, pow2\n\n\nclass Test(TestCase):\n    def test_pow1(self):\n        x = random.randint(1, 10)\n        for n in range(10):\n            self.assertEqual(pow1(x, n), math.pow(x, n))\n\n    def test_pow2(self):\n        x = random.randint(1, 10)\n        for n in range(10):\n            self.assertEqual(pow2(x, n), math.pow(x, n))\n\n"
    },
    {
        "case number": "151",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "152",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "153",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "154",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "155",
        "code": "from typing import Union\n\nfrom .utils.to_int import to_int\n\n\ndef is_even(input: Union[int, str]) -> bool:\n    input = to_int(input)\n\n    if input is None:\n        return False\n\n    return not bool(input % 2)\n\n",
        "unittest": "import unittest\n\nfrom pyvalidator.is_even import is_even\nfrom . import print_test_ok\n\n\nclass TestIsEven(unittest.TestCase):\n    def valid_check(self, items):\n        for item in items:\n            try:\n                self.assertTrue(is_even(item))\n            except Exception as e:\n                print(f'failed for input: {item}')\n                raise e\n\n    def invalid_check(self, items):\n        for item in items:\n            try:\n                self.assertFalse(is_even(item))\n            except Exception as e:\n                print(f'failed for input: {item}')\n                raise e\n\n    def test_valid_even(self):\n        valid_items = [\n            0,\n            2,\n            4,\n            6,\n            8,\n            10,\n            12,\n            120,\n            1000,\n            -1000,\n            '1000',\n            '2',\n            '120',\n            '666',\n            '-888'\n        ]\n        self.valid_check(valid_items)\n        print_test_ok()\n\n    def test_invalid_even(self):\n        invalid_items = [\n            ' ',\n            'a',\n            '.1',\n            '1.0',\n            3,\n            5,\n            111,\n            -7,\n            '17',\n            '-21',\n            '121'\n        ]\n        self.invalid_check(invalid_items)\n        print_test_ok()\n\n"
    },
    {
        "case number": "156",
        "code": "\"\"\"https://leetcode.com/problems/integer-to-roman/\"\"\"\nimport math\n\n\ndef int_to_roman(num):\n    \"\"\"\n    Time complexity: O(n*log(n))\n    Space complexity: O(n*log(n))\n\n    :type num: int\n    :rtype: str\n    \"\"\"\n    stack = [\n        (\"I\", 1),\n        (\"IV\", 4),\n        (\"V\", 5),\n        (\"IX\", 9),\n        (\"X\", 10),\n        (\"XL\", 40),\n        (\"L\", 50),\n        (\"XC\", 90),\n        (\"C\", 100),\n        (\"CD\", 400),\n        (\"D\", 500),\n        (\"CM\", 900),\n        (\"M\", 1000),\n    ]\n\n    roman = \"\"\n    while num > 0:\n        count = math.floor(num / stack[-1][1])\n        if count > 0:\n            roman += stack[-1][0] * count\n            num -= stack[-1][1] * count\n        stack.pop()\n\n    return roman\n",
        "unittest": "import pytest\nfrom dsa.problems.int_to_roman import int_to_roman\n\n\n@pytest.mark.parametrize(\"value, expected\", [\n    (3, \"III\"),\n    (58, \"LVIII\"),\n    (1994, \"MCMXCIV\"),\n    (2021, \"MMXXI\"),\n    (420, \"CDXX\"),\n    (69, \"LXIX\"),\n])\ndef test_int_to_roman(value, expected):\n    assert int_to_roman(value) == expected\n\n"
    },
    {
        "case number": "157",
        "code": "import math\n\ndef circum_circle_radius(a, b, c):\n  # Circumcircle radius calculation from http://www.mathopenref.com/trianglecircumcircle.html\n  if a > 0 and b > 0 and c > 0:\n    try:\n      divider = math.sqrt(math.fabs((a+b+c)*(b+c-a)*(c+a-b)*(a+b-c)))\n      return (a * b * c) / divider\n    except ZeroDivisionError:\n      return 10000\n  else:\n    return 10000\n\n",
        "unittest": "from curvature.radiusmath import circum_circle_radius \n\ndef test_circum_circle_radius_zero_lengths():\n  assert circum_circle_radius(0, 0, 0) == 10000\n\ndef test_circum_circle_radius_zero_division():\n  assert circum_circle_radius(0.13430093277996386, 0.13430093277996386, 0.2686018655599277) == 10000\n"
    },
    {
        "case number": "158",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "159",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "160",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "161",
        "code": "",
        "unittest": ""
    },
    {
        "case number": "162",
        "code": "#!/usr/bin/evn python\n# coding=utf-8\n\nimport hashlib\n\ndef md5(text):\n    \"\"\"md5\u52a0\u5bc6\u51fd\u6570\"\"\"\n    md5 = hashlib.md5()\n    if not isinstance(text, bytes):\n        text = str(text).encode('utf-8')\n    md5.update(text)\n    return md5.hexdigest()\n\n",
        "unittest": "#!/usr/bin/evn python\n# coding=utf-8\n\nimport unittest\nfrom common import encrypt_helper\n\n\nclass EncryptHelperTest(unittest.TestCase):\n    \"\"\"\u52a0\u5bc6\u64cd\u4f5c\u5305\u6d4b\u8bd5\u7c7b\"\"\"\n\n    def setUp(self):\n        \"\"\"\u521d\u59cb\u5316\u6d4b\u8bd5\u73af\u5883\"\"\"\n        print('------ini------')\n\n    def tearDown(self):\n        \"\"\"\u6e05\u7406\u6d4b\u8bd5\u73af\u5883\"\"\"\n        print('------clear------')\n\n    def test(self):\n        result = encrypt_helper.md5(1)\n        print(result)\n        self.assertEqual(result, 'c4ca4238a0b923820dcc509a6f75849b')\n\n        result = encrypt_helper.md5('1')\n        print(result)\n        self.assertEqual(result, 'c4ca4238a0b923820dcc509a6f75849b')\n\n        result = encrypt_helper.md5(b'1')\n        print(result)\n        self.assertEqual(result, 'c4ca4238a0b923820dcc509a6f75849b')\n\nif __name__ == '__main__':\n    unittest.main()\n\n"
    },
    {
        "case number": "163",
        "code": "\"\"\"\nA simple implementation of RFC 1982 serial number arithmetic\nto handle wrapping of packet sequence numbers.\n\n* https://tools.ietf.org/html/rfc1982\n\nNote that when incrementing a serial number, one is allowed\nto add up to (2 ** bits - 1) - 1.\n\"\"\"\n\n\ndef serial_lt(a: int, b: int, bits: int = 32) -> bool:\n    half = 2 ** (bits - 1)\n    return (a < b and (b - a) < half) or (a > b and (a - b) > half)\n\n\ndef serial_gt(a: int, b: int, bits: int = 32) -> bool:\n    half = 2 ** (bits - 1)\n    return (a < b and (b - a) > half) or (a > b and (a - b) < half)\n\n\ndef serial_le(a: int, b: int, bits: int = 32) -> bool:\n    return a == b or serial_lt(a, b, bits)\n\n\ndef serial_ge(a: int, b: int, bits: int = 32) -> bool:\n    return a == b or serial_gt(a, b, bits)\n\n",
        "unittest": "from callosum.serial import serial_gt, serial_lt\n\n\ndef test_serial_comparison():\n    assert serial_lt(1, 2, bits=8)\n    assert not serial_lt(2, 1, bits=8)\n\n    assert serial_lt(255, 100, bits=8)\n    assert serial_lt(255, 126, bits=8)\n    assert not serial_lt(255, 127, bits=8)\n    assert not serial_lt(255, 200, bits=8)\n\n    assert not serial_gt(1, 2, bits=8)\n    assert serial_gt(2, 1, bits=8)\n\n    assert not serial_gt(255, 100, bits=8)\n    assert not serial_gt(255, 127, bits=8)\n    assert serial_gt(255, 128, bits=8)\n    assert serial_gt(255, 200, bits=8)\n\n"
    }
]